first person shooter
multiplayer
free for all
singleplayer

-- Rules --

-- Context Diagram --
server -- snapshots --> NETWORK <-- usercmds -- client

-- Dataflow Diagram --

-- Structure Chart --
- nuko
  - client
    - console
      -> keyboard input
      -> command input
      
      <- function_callback
    - input
      -> function_callback
      -> mouse_input
      
      <- usercmd
    - cgame
      -> usercmd
      -> snapshot
      -> map_handle
      
      - bsp
        -> map_handle
        <- bspnodes
      
      - systems
        -> entities
        -> components
        <- entities next frame
      
      <- gamestate
    - renderer
      -> gamestate
      -> map_handle
      
      - map_mesh
        -> map_handle
        <- vertices
        <- textures
      - mesh_pool
        -> vertices
        <- mesh object on GPU
      - shader
        -> uncompiled shader program
        <- compiled shader program on GPU
      - draw_mesh
        -> mesh
        <- visual output
      
      <- visual graphics
    - networking
      -> usercmd
      -> snapshot from network
      
      <- usercmd over the network
      <- snapshot
  - server
    - networking
      -> usercmd from the network
      -> snapshot
      
      <- usercmd, entity_id
      <- snapshot over the network
    - game
      -> usercmd, entity_id
      -> map_handle
      
      - bsp
        -> map_handle
        <- bspnodes
      
      - systems
        -> entities
        -> components
        
        <- entities next frame
      
      <- gamestate

-- IPO --

<Processes>
- Client Game
- Systems
- Console
- Input

- Renderer
- Map Mesh
- Mesh Pool
- Shader

- Server Game

- Network

- BSP Generation

<Client Game>
Input
  usercmds

Process
  Advance the game state per update using input usercmds

Output
  The new gamestate

<Systems>
Input
  Entities, Components, Systems

Process
  From the component data, and entities as references, the systems should apply
  the necessary game logic to advance the entities into the next state

Output
  The entities in the next game state

<Console>
Input
  commands
  keybinds

Process
  Parse the commands, or listen for keypresses bound to certain commands and
  execute the process associated with said command.

Output
  Call the function associated with the command being ran

<Input>
  callbacks from console
  mouse input

Process
  From the callbacks and mouse inputs, build a usercmd correpsending to the
  action of the client

Output
  usercmd

<Renderer>
  gamestate

Process
  from the gamestate, produce a graphical representation of it

Output
  on screen graphics

<Map Mesh>
Input
  map

Process
  Process into necessary format, able to be rendered

Output
  vertices, textures

<Mesh Pool>
Input
  Vertices

Process
  Pool the vertices into a single vertex buffer object on the GPU which is able
  to be rendered

Output
  Mesh which can be drawn

<Shader>
Input
  uncompiled shader program written in glsl

Process
  Compile the shader and load it into GPU

Output
  boundable shader capable of manipulating visual graphics

-- Data Dicionary --

<Math>
vec3_t
  float         x;
  float         y;
  float         z;

quat_t
  float         x;
  float         y;
  float         z;

mat4_t
  float         m[16];

<Map>
vertex_t
  vec3_t        pos;
  vec2_t        uv;

face_t
  vertex_t      veritces[];

brush_t
  face_t        faces[];

map_handle_t
  brush_t       brushes[];
  brushgroup_t  brushgroups[];
  material_t    materials[];

<BSP>
bsp_t
  bspnode_t     bspnodes[];

bspnode_t
  plane_t       plane;
  bspnode_t     *behind;
  bspnode_t     *ahead;

clip_t
  hull_t        hull;
  bspnode_t     bspnode;
  ray_t         ray;
  plane_t       plane;

<Data Types>
usercmd_t
  float         forward;
  float         right;
  float         yaw;
  float         pitch;
  bool          jump;
  bool          shoot;

snapshot_t
  c_transform_t c_transform[];
  c_health_t    c_health[];

hull_t
  plane_t       planes[];

cdict_t<T>
  T             components[];
  Uint8Array    entity_lookup;

edict_t
  int           max_entities;
  int           num_entities;

<Components>

[Common]
c_transform_t
  vec3_t        pos;
  quat_t        rot;

c_motion_t
  vec3_t        old_pos;
  vec3_t        force;
  float         inverse_mass;

c_cliententity_t
  usercmd_t     usercmd;

c_clip_t
  brushclip_t   brushclips[];

c_capsule_t
  float         height;
  float         radius;

[Client]
c_client_t
  usercmd_t     old_cmd[];

c_serverentity_t
  vec3_t        old_pos;
  vec3_t        new_pos;

c_model_t
  e_model_t     model;

[Server]
c_health_t
  float         health;
  float         max_health;
  float         min_health;

c_damage_t
  float         health_loss;

c_score_t
  float         total_score;

<Game>
cgame_t
  bsp_t         bsp;
  
  cdict_t       c_serverentity<c_serverentity_t>;
  cdict_t       c_transform<c_transform_t>;
  cmotion_t     c_motion;
  c_clip_t      c_clip;
  c_client_t    c_client;

game_t
  bsp_t         bsp;
  
  cdict_t       c_cliententity<c_cliententity_t>;
  cdict_t       c_transform<c_transform_t>;
  cdict_t       c_motion<c_motion_t>;
  cdict_t       c_clip<c_clip_t>;

<Systems>

[Client]
  s_reconcile_t
  s_shoot_t
  s_move_t
  s_gravity_t
  s_collide_t
  s_clip_t
  s_integrate_t
  s_death_t

[Server]
  s_shoot_t
  s_move_t
  s_gravity_t
  s_clip_t
  s_damage_t
  s_death_t

PSEUDOCODE

---------------------

use uint8array as lookup table for cdict_t

modules
nuko
- client
  - client game
    -> usercmd_t
    -> map_handle_t
    
    - common_components
    - c_model_t
    
    - common_systems
    - s_interpolate_t
    - s_reconcilliation_t
    
    <- components
  - console
    -> keybindings
    -> console commands
    
    <- fn_callback
  - networking
    -> usercmd_t
    
    - poll
    - send_cmd
    
    <- snapshots
  - input
    -> function callbacks
    -> mouse input
    
    <- usercmd_t
  - renderer
    -> c_model_t
    -> map_handle
    
    <- screen
  - gui
    -> health
    -> console
    -> chat
    
    <- health bar
    <- console gui
    <- chat

- server
  - networking
    
  - server game
    -> entity_id, usercmd_t
    
    - common_components
    - common_systems
    
    <- snapshot_t
  - snapshot_t
    - c_transform_t
